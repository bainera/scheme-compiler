/* 
* run-time support aritmethic functions
*/

/******** ADDITION VARIADIC  *********/
PLUS_BODY:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
PUSH(R2);


MOV(R1,FPARG(1));  //R1 = num of args

CMP(R1,0);
JUMP_NE(PLUS_LOOP_START);
PUSH(IMM(0)); 
CALL(MAKE_SOB_INTEGER);
DROP(1); 
JUMP(PLUS_BODY_END);

PLUS_LOOP_START:
CMP(R1,IMM(2)); // while num of args >=2
JUMP_LT(PLUS_BODY_2);
INCR(R1);
PUSH(FPARG(R1));
DECR(R1);
PUSH(FPARG(R1));
CALL(BINARY_PLUS);
DROP(2);
MOV(FPARG(R1),R0);
DECR(R1);
JUMP(PLUS_LOOP_START);

PLUS_BODY_2:
MOV(R0,FPARG(2)); //put last result(or the only arg) in R0

PLUS_BODY_END:
POP(R2);
POP(R1);
POP(FP);
RETURN;


BINARY_PLUS:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
PUSH(R2);
PUSH(R3);

MOV(R1,FPARG(0));
PUSH(FPARG(0));
PUSH(IMM(1)); //number of args
PUSH(IMM(999)); //FAKE ENV
CALL(INTEGER_BODY);
DROP(3);
JUMP_NE(PLUS_FIRST_IS_FRAC);
PUSH(FPARG(0));
CALL(INT_TO_FRAC);
DROP(1);
MOV(R1,R0);

PLUS_FIRST_IS_FRAC:
MOV(R2,FPARG(1));
PUSH(FPARG(1));
PUSH(IMM(1)); //number of args
PUSH(IMM(999)); //FAKE ENV
CALL(INTEGER_BODY);
DROP(3);
JUMP_NE(PLUS_BOTH_FRAC);
PUSH(FPARG(1));
CALL(INT_TO_FRAC);
MOV(R2,R0);
DROP(1);

PLUS_BOTH_FRAC:
MOV(R0,0);
MOV(R3, INDD(R1,2));
MUL(R3,INDD(R2,2));
ADD(R0,R3);
PUSH(R0);

MOV(R0,0);
MOV(R3, INDD(R1,1));
MUL(R3,INDD(R2,2));
ADD(R0,R3);
MOV(R3, INDD(R2,1));
MUL(R3,INDD(R1,2));
ADD(R0,R3);
PUSH(R0);

CALL(MAKE_SOB_FRAC);
DROP(2);

MOV(R1,INDD(R0,1));
MOV(R2,INDD(R0,2));
REM(R1,R2);
CMP(R1,0);
JUMP_NE(BINARY_PLUS_END);
PUSH(R0);
CALL(FRAC_TO_INT);
DROP(1);

BINARY_PLUS_END:
POP(R3);
POP(R2);
POP(R1);
POP(FP);
RETURN;


/****************************************/
/******** SUBTRACTION VARIADIC **********/
/****************************************/

MINUS_BODY:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
PUSH(R2);
PUSH(R3);
PUSH(R4);

MOV(R3,FPARG(1));  //R1 = num of args

CMP(R3,IMM(1));
JUMP_NE(MINUS_MORE_THAN_ONE_ARG);
PUSH(IMM(0)); 
CALL(MAKE_SOB_INTEGER);
DROP(1); 
PUSH(FPARG(2));
PUSH(R0);
CALL(BINARY_MINUS);
DROP(2);
JUMP(MINUS_BODY_END);

MINUS_MORE_THAN_ONE_ARG:
MOV(R2,FPARG(2)); //R2 will hold the result
MOV(R1,1); // R1 hold the number of args we have already used.

MINUS_LOOP_START:
CMP(R1,R3); // while we still have args we havent used
JUMP_EQ(MINUS_BODY_END);
MOV(R4,R3);
ADD(R4,IMM(2));
SUB(R4,R1); //fparg(R4) is the next arg we need
PUSH(FPARG(R4));
PUSH(R2);
CALL(BINARY_MINUS);
DROP(2);
MOV(R2,R0);
INCR(R1);
JUMP(MINUS_LOOP_START);

MINUS_BODY_END:
POP(R4);
POP(R3);
POP(R2);
POP(R1);
POP(FP);
RETURN;


BINARY_MINUS:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
PUSH(R2);
PUSH(R3);

MOV(R1,FPARG(0));
PUSH(FPARG(0));
PUSH(IMM(1)); //number of args
PUSH(IMM(999)); //FAKE ENV
CALL(INTEGER_BODY);
DROP(3);
JUMP_NE(MINUS_FIRST_IS_FRAC);
PUSH(FPARG(0));
CALL(INT_TO_FRAC);
DROP(1);
MOV(R1,R0);

MINUS_FIRST_IS_FRAC:
MOV(R2,FPARG(1));
PUSH(FPARG(1));
PUSH(IMM(1)); //number of args
PUSH(IMM(999)); //FAKE ENV
CALL(INTEGER_BODY);
DROP(3);
JUMP_NE(MINUS_BOTH_FRAC);
PUSH(FPARG(1));
CALL(INT_TO_FRAC);
MOV(R2,R0);
DROP(1);

MINUS_BOTH_FRAC:
MOV(R0,0);
MOV(R3, INDD(R1,2));
MUL(R3,INDD(R2,2));
ADD(R0,R3);
PUSH(R0);

MOV(R0,0);
MOV(R3, INDD(R1,1));
MUL(R3,INDD(R2,2));
ADD(R0,R3);

MOV(R3, INDD(R2,1));
MUL(R3,INDD(R1,2));
SUB(R0,R3);
PUSH(R0);

CALL(MAKE_SOB_FRAC);
DROP(2);

MOV(R1,INDD(R0,1));
MOV(R2,INDD(R0,2));
REM(R1,R2);
CMP(R1,0);
JUMP_NE(BINARY_MINUS_END);
PUSH(R0);
CALL(FRAC_TO_INT);
DROP(1);

BINARY_MINUS_END:
POP(R3);
POP(R2);
POP(R1);
POP(FP);
RETURN;



/*******************************************/
/******** MULTIPLICATION VARIADIC **********/
/*******************************************/

MULTI_BODY:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
PUSH(R2);


MOV(R1,FPARG(1));  //R1 = num of args

CMP(R1,0);
JUMP_NE(MULTI_LOOP_START);
PUSH(IMM(0)); 
CALL(MAKE_SOB_INTEGER);
DROP(1); 
JUMP(MULTI_BODY_END);

MULTI_LOOP_START:
CMP(R1,IMM(2)); // while num of args >=2
JUMP_LT(MULTI_BODY_2);
INCR(R1);
PUSH(FPARG(R1));
DECR(R1);
PUSH(FPARG(R1));
CALL(BINARY_MULTI);
DROP(2);
MOV(FPARG(R1),R0);
DECR(R1);
JUMP(MULTI_LOOP_START);

MULTI_BODY_2:
MOV(R0,FPARG(2));

MULTI_BODY_END:
POP(R2);
POP(R1);
POP(FP);
RETURN;


BINARY_MULTI:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
PUSH(R2);
PUSH(R3);

MOV(R1,FPARG(0));
PUSH(FPARG(0));
PUSH(IMM(1)); //number of args
PUSH(IMM(999)); //FAKE ENV
CALL(INTEGER_BODY);
DROP(3);
JUMP_NE(MULTI_FIRST_IS_FRAC);
PUSH(FPARG(0));
CALL(INT_TO_FRAC);
DROP(1);
MOV(R1,R0);

MULTI_FIRST_IS_FRAC:
MOV(R2,FPARG(1));
PUSH(FPARG(1));
PUSH(IMM(1)); //number of args
PUSH(IMM(999)); //FAKE ENV
CALL(INTEGER_BODY);
DROP(3);
JUMP_NE(MULTI_BOTH_FRAC);
PUSH(FPARG(1));
CALL(INT_TO_FRAC);
MOV(R2,R0);
DROP(1);

MULTI_BOTH_FRAC:

MOV(R3,INDD(R2,2));
MUL(R3,INDD(R1,2));
MOV(R0,R3);
PUSH(R0);
MOV(R3,INDD(R1,1));
MUL(R3,INDD(R2,1));
MOV(R0,R3);
PUSH(R0);


CALL(MAKE_SOB_FRAC);
DROP(2);

MOV(R1,INDD(R0,1));
MOV(R2,INDD(R0,2));
REM(R1,R2);
CMP(R1,0);
JUMP_NE(BINARY_MULTI_END);
PUSH(R0);
CALL(FRAC_TO_INT);
DROP(1);

BINARY_MULTI_END:

POP(R3);
POP(R2);
POP(R1);
POP(FP);
RETURN;


/************************************/
/******** DIVIDE VARIADIC ***********/
/***********************************/
DIVIDE_BODY:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
PUSH(R2);
PUSH(R3);
PUSH(R4);

MOV(R3,FPARG(1));  //R1 = num of args

CMP(R3,IMM(1));
JUMP_NE(DIVIDE_MORE_THAN_ONE_ARG);
PUSH(IMM(1)); 
CALL(MAKE_SOB_INTEGER);
DROP(1); 
PUSH(FPARG(2));
PUSH(R0);
CALL(BINARY_DIVIDE);
DROP(2);
JUMP(DIVIDE_BODY_END);

DIVIDE_MORE_THAN_ONE_ARG:
MOV(R2,FPARG(2)); //R2 will hold the result
MOV(R1,1); // R1 hold the number of args we have already used.

DIVIDE_LOOP_START:
CMP(R1,R3); // while we still have args we havent used
JUMP_EQ(DIVIDE_BODY_END);
MOV(R4,R3);
ADD(R4,IMM(2));
SUB(R4,R1); //fparg(R4) is the next arg we need
PUSH(FPARG(R4));
PUSH(R2);
CALL(BINARY_DIVIDE);
DROP(2);
MOV(R2,R0);
INCR(R1);
JUMP(DIVIDE_LOOP_START);

DIVIDE_BODY_END:
POP(R4);
POP(R3);
POP(R2);
POP(R1);
POP(FP);
RETURN;


BINARY_DIVIDE:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
PUSH(R2);
PUSH(R3);

MOV(R1,FPARG(0));
PUSH(FPARG(0));
PUSH(IMM(1)); //number of args
PUSH(IMM(999)); //FAKE ENV
CALL(INTEGER_BODY);
DROP(3);
JUMP_NE(DIVIDE_FIRST_IS_FRAC);
PUSH(FPARG(0));
CALL(INT_TO_FRAC);
DROP(1);
MOV(R1,R0);

DIVIDE_FIRST_IS_FRAC:
MOV(R2,FPARG(1));
PUSH(FPARG(1));
PUSH(IMM(1)); //number of args
PUSH(IMM(999)); //FAKE ENV
CALL(INTEGER_BODY);
DROP(3);
JUMP_NE(DIVIDE_BOTH_FRAC);
PUSH(FPARG(1));
CALL(INT_TO_FRAC);
MOV(R2,R0);
DROP(1);

DIVIDE_BOTH_FRAC:

MOV(R3, INDD(R1,2));
MUL(R3,INDD(R2,1));
MOV(R0,R3);
PUSH(R0);

MOV(R3, INDD(R1,1));
MUL(R3,INDD(R2,2));
MOV(R0,R3);
PUSH(R0);

CALL(MAKE_SOB_FRAC);
DROP(2);

MOV(R1,INDD(R0,1));
MOV(R2,INDD(R0,2));
REM(R1,R2);
CMP(R1,0);
JUMP_NE(BINARY_DEVIDE_END);
PUSH(R0);
CALL(FRAC_TO_INT);
DROP(1);

BINARY_DEVIDE_END:
POP(R3);
POP(R2);
POP(R1);
POP(FP);
RETURN;

/************************************/
/********  REMINDER      ***********/
/***********************************/
REMINDER_BODY:
PUSH(FP);
MOV(FP,SP);
PUSH(R1);
MOV(R0,FPARG(2));
MOV(R0,INDD(R0,1));
MOV(R1,FPARG(3));
MOV(R1,INDD(R1,1));
REM(R0,R1);
PUSH(R0);
CALL(MAKE_SOB_INTEGER);
DROP(1);
POP(R1);
POP(FP);
RETURN;